/****************************************************************************
**
** Copyright (C) 2019 Luxoft Sweden AB
** Contact: https://www.qt.io/licensing/
**
** This file is part of the documentation of the Qt Application Manager.
**
** $QT_BEGIN_LICENSE:FDL-QTAS$
** Commercial License Usage
** Licensees holding valid commercial Qt Automotive Suite licenses may use
** this file in accordance with the commercial license agreement provided
** with the Software or, alternatively, in accordance with the terms
** contained in a written agreement between you and The Qt Company.  For
** licensing terms and conditions see https://www.qt.io/terms-conditions.
** For further information use the contact form at https://www.qt.io/contact-us.
**
** GNU Free Documentation License Usage
** Alternatively, this file may be used under the terms of the GNU Free
** Documentation License version 1.3 as published by the Free Software
** Foundation and appearing in the file included in the packaging of
** this file. Please review the following information to ensure
** the GNU Free Documentation License version 1.3 requirements
** will be met: https://www.gnu.org/licenses/fdl-1.3.html.
** $QT_END_LICENSE$
**
****************************************************************************/

/*!

\example applicationmanager/application-features
\title Application Features Example
\image application-features.png
\brief Showcases client applications with various features, including a native application.
\ingroup applicationmanager-examples

\section1 Introduction

This example demonstrates some particular features that an application might implement, for
instance it shows how to implement a nested compositor and it is the only example with an
application that uses the "native" runtime. Most of the features are only supported properly in
multi-process mode (for details see the following section).

\note This example focuses on the application (client) side. The System UI (compositor/server) is just a
modified version of the "Desktop System UI Example" (minidesk). For more information on how this
System UI is implemented, see \l{Desktop System UI Example}.


\section1 The Client Applications

The following applications are included in this example:

\section2 Nested Compositor
The nested compositor application shows how a Wayland compositor can be implemented inside an
application (Wayland client) window. The compositor is implemented in pure QML and is kept to a
minimum. In order to display Wayland clients inside this compositor, the WAYLAND_DISPLAY
environment variable needs to be set appropriately. Starting a client on the command line could be
done like this:
\badcode
WAYLAND_DISPLAY=qtam-wayland-nested qmlscene client.qml -platform wayland
\endcode
Note that this works only in multi-process mode, since the nested compositor needs a real window as
its root element.

\section2 Crash Simulation and Recovery
The crash application provides various means to force a crash in the application, like a
segmentation fault. It utilizes a QML plugin implemented in C++, that provides the \c Terminator
QML type to trigger crashes. The application manager will print the cause of the crash and other
information like a backtrace. The System UI implements a basic form of crash recovery: it simply
restarts the application. Note that this works only in mulit-process mode. In single process mode a
crash will affect the entire (System UI) program.

\section2 Two Top-Level Windows
This application shows how multiple top-level windows can be displayed by having a QtObject as the
application's root element.

\section2 Native Widgets
The native widgets application is based on \l{QWidget}s. In contrast to the other applications
which are QML applications, this one uses the "native" runtime. Consequently, the application's
entry point isn't a main QML file, but an executable. It is probably the most basic application,
that still adheres to this particular System UI. It is just for illustrating the concept: the
System UI needs a \c type window property to differentiate between normal windows and popups. Note
that this works only in multi-process mode; naturally, application processes cannot be started in
single-process mode.
\endlist

\section1 Code Structure
In contrast to other application manager examples, which are purely based on QML, this example
needs to be built necessarily. The code is structured in a way, that the resulting application
folders only contain the needed artifacts to run the application. Hence they could be packaged and
installed, as well (for instance to the \l{Desktop System UI Example}).

*/
